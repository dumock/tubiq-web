'use client';

import { useState, useRef, useEffect } from 'react';
import Header from '@/components/Header';
import { supabase } from '@/lib/supabase';
import { Upload, FileText, Play, Pause, Download, Globe, Wand2, Plus, Trash2, Save, Video as VideoIcon, Pin, PinOff, RefreshCw } from 'lucide-react';

interface Subtitle {
    id: string;
    startTime: number;
    endTime: number;
    text: string;
    translatedText?: string; // For bilingual display
    animation?: string;
    fontSize?: string;
    fontFamily?: string;
}

export default function SubtitleMakerPage() {
    // Media State
    const [videoUrl, setVideoUrl] = useState<string | null>(null);
    const [videoFile, setVideoFile] = useState<File | null>(null);
    const [audioFile, setAudioFile] = useState<File | null>(null);
    const [scriptText, setScriptText] = useState('');

    // Subtitle State
    const [subtitles, setSubtitles] = useState<Subtitle[]>([]);
    const [selectedSubtitleId, setSelectedSubtitleId] = useState<string | null>(null);

    // Playback State
    const [isPlaying, setIsPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState(0);
    const videoRef = useRef<HTMLVideoElement>(null);

    // Tools State
    const [isGenerating, setIsGenerating] = useState(false);
    const [isSyncing, setIsSyncing] = useState(false);
    const [isTranslating, setIsTranslating] = useState(false);
    const [isInputPanelOpen, setIsInputPanelOpen] = useState(false);
    const [isToolbarSticky, setIsToolbarSticky] = useState(true);

    // Animation State
    const [animationStyle, setAnimationStyle] = useState('none');

    const ANIMATION_STYLES = [
        { id: 'none', label: 'ÏóÜÏùå', class: '' },
        { id: 'fade', label: 'Fade', class: 'animate-fade' },
        { id: 'pop', label: 'Pop', class: 'animate-pop' },
        { id: 'slide-up', label: 'Slide‚Üë', class: 'animate-slide-up' },
        { id: 'slide-down', label: 'Slide‚Üì', class: 'animate-slide-down' },
        { id: 'typewriter', label: 'Typewriter', class: 'animate-typewriter overflow-hidden whitespace-nowrap border-r-4 border-white pr-1' },
        { id: 'neon', label: 'Neon', class: 'animate-neon' },
        { id: 'shake', label: 'Shake', class: 'animate-shake' },
        { id: 'zoom-out', label: 'Zoom', class: 'animate-zoom-out' },
        { id: 'blur', label: 'Blur', class: 'animate-blur' },
        { id: 'flip', label: '3D Flip', class: 'animate-flip' },
    ];

    const FONT_SIZES = [
        { id: '16', label: '16', class: 'text-[16px]' },
        { id: '20', label: '20', class: 'text-[20px]' },
        { id: '24', label: '24', class: 'text-[24px]' },
        { id: '28', label: '28', class: 'text-[28px]' },
        { id: '32', label: '32', class: 'text-[32px]' },
        { id: '40', label: '40', class: 'text-[40px]' },
    ];

    const FONT_FAMILIES = [
        { id: 'malgun', label: 'ÎßëÏùÄ Í≥†Îîï', style: { fontFamily: '"Malgun Gothic", "ÎßëÏùÄ Í≥†Îîï", sans-serif' } },
        { id: 'nanum', label: 'ÎÇòÎàîÍ≥†Îîï', style: { fontFamily: '"NanumGothic", "ÎÇòÎàîÍ≥†Îîï", sans-serif' } },
        { id: 'gulim', label: 'Íµ¥Î¶º', style: { fontFamily: '"Gulim", "Íµ¥Î¶º", sans-serif' } },
        { id: 'dotum', label: 'ÎèãÏõÄ', style: { fontFamily: '"Dotum", "ÎèãÏõÄ", sans-serif' } },
        { id: 'batang', label: 'Î∞îÌÉï', style: { fontFamily: '"Batang", "Î∞îÌÉï", serif' } },
        { id: 'gungsuh', label: 'Í∂ÅÏÑú', style: { fontFamily: '"Gungsuh", "Í∂ÅÏÑú", serif' } },
        { id: 'arial', label: 'Arial', style: { fontFamily: 'Arial, sans-serif' } },
        { id: 'impact', label: 'Impact', style: { fontFamily: 'Impact, sans-serif' } },
        { id: 'times', label: 'Times New Roman', style: { fontFamily: '"Times New Roman", serif' } },
        { id: 'comic', label: 'Comic Sans', style: { fontFamily: '"Comic Sans MS", cursive' } },
    ];

    const TRANSLATION_LANGUAGES = [
        { id: 'en', label: 'English (ÏòÅÏñ¥)' },
        { id: 'ja', label: 'Êó•Êú¨Ë™û (ÏùºÏñ¥)' },
        { id: 'zh', label: '‰∏≠Êñá (Ï§ëÍµ≠Ïñ¥)' },
        { id: 'es', label: 'Espa√±ol (Ïä§ÌéòÏù∏Ïñ¥)' },
    ];

    // Translation State
    const [selectedTranslationLang, setSelectedTranslationLang] = useState('en');

    // Subtitle Display Options
    const [showSubtitleBackground, setShowSubtitleBackground] = useState(false);

    // Subtitle Position (percentage based: x: 0-100, y: 0-100)
    const [subtitlePosition, setSubtitlePosition] = useState({ x: 50, y: 75 });
    const [subtitleWidth, setSubtitleWidth] = useState(80); // percentage width
    const [isDragging, setIsDragging] = useState(false);
    const [isResizing, setIsResizing] = useState(false);
    const videoContainerRef = useRef<HTMLDivElement>(null);

    // Drag handlers for subtitle position
    const handleSubtitleDragStart = (e: React.MouseEvent | React.TouchEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    };

    const handleSubtitleDrag = (e: React.MouseEvent | React.TouchEvent) => {
        if (!videoContainerRef.current) return;

        const container = videoContainerRef.current.getBoundingClientRect();
        let clientX: number, clientY: number;

        if ('touches' in e) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        if (isResizing) {
            // Calculate width based on distance from center
            const centerX = container.left + container.width * (subtitlePosition.x / 100);
            const distanceFromCenter = Math.abs(clientX - centerX);
            const newWidth = (distanceFromCenter / container.width) * 200; // *2 because we measure from center
            setSubtitleWidth(Math.max(30, Math.min(95, newWidth)));
        } else if (isDragging) {
            const x = ((clientX - container.left) / container.width) * 100;
            const y = ((clientY - container.top) / container.height) * 100;
            setSubtitlePosition({
                x: Math.max(5, Math.min(95, x)),
                y: Math.max(5, Math.min(95, y))
            });
        }
    };

    const handleSubtitleDragEnd = () => {
        setIsDragging(false);
        setIsResizing(false);
    };

    const handleResizeStart = (e: React.MouseEvent | React.TouchEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsResizing(true);
    };

    // Drag and drop state
    const [isDragOver, setIsDragOver] = useState(false);
    const dragCounter = useRef(0);

    const handleDragEnter = (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        dragCounter.current++;
        if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
            setIsDragOver(true);
        }
    };

    const handleDragOver = (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
    };

    const handleDragLeave = (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        dragCounter.current--;
        if (dragCounter.current === 0) {
            setIsDragOver(false);
        }
    };

    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragOver(false);
        dragCounter.current = 0;

        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const file = files[0];
            const isVideo = file.type.startsWith('video/');
            const isAudio = file.type.startsWith('audio/');

            if (isVideo) {
                setVideoFile(file);
                setVideoUrl(URL.createObjectURL(file));
            } else if (isAudio) {
                setAudioFile(file);
            }
        }
    };

    const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            setVideoFile(file);
            setVideoUrl(URL.createObjectURL(file));
        }
    };

    const handleTimeUpdate = () => {
        if (videoRef.current) {
            setCurrentTime(videoRef.current.currentTime);
        }
    };

    const togglePlay = () => {
        if (videoRef.current) {
            if (isPlaying) {
                videoRef.current.pause();
            } else {
                videoRef.current.play();
            }
            setIsPlaying(!isPlaying);
        }
    };

    const handleGenerateSubtitles = async () => {
        if (!scriptText) return alert('ÎåÄÎ≥∏ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
        if (!videoFile && !audioFile) return alert('ÏòÅÏÉÅ ÎòêÎäî ÏùåÏÑ± ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.');

        setIsGenerating(true);
        try {
            const { data: { session } } = await supabase.auth.getSession();
            const token = session?.access_token;

            const formData = new FormData();
            if (videoFile) formData.append('video', videoFile);
            if (audioFile) formData.append('audio', audioFile);
            formData.append('script', scriptText);

            const response = await fetch('/api/subtitle/generate', {
                method: 'POST',
                headers: {
                    'Authorization': token ? `Bearer ${token}` : ''
                },
                body: formData
            });

            if (!response.ok) {
                const err = await response.text();
                throw new Error(err);
            }

            const result = await response.json();
            if (result.ok && result.data) {
                // Map API response to Subtitle interface
                // Remove punctuation marks from subtitle text
                const removePunctuation = (text: string) =>
                    text.replace(/[.,!?;:'"()\[\]{}‚Ä¶¬∑„ÄÅ„ÄÇÔºÅÔºüÔºå„ÄÇ„Äå„Äç„Äé„Äè„Äê„Äë„Äà„Äâ„Ää„Äã]/g, '').trim();

                const newSubtitles = result.data.map((item: any, idx: number) => ({
                    id: `gen-${idx}`,
                    startTime: item.start,
                    endTime: item.end,
                    text: removePunctuation(item.text),
                    animation: 'none',
                    fontSize: '16',
                    fontFamily: 'malgun'
                }));
                setSubtitles(newSubtitles);
            } else {
                throw new Error(result.message || 'Generation failed');
            }

        } catch (error) {
            console.error('Failed to generate subtitles:', error);
            alert('ÏûêÎßâ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. (ÌååÏùºÏù¥ ÎÑàÎ¨¥ ÌÅ¨Í±∞ÎÇò API Î¨∏Ï†úÏùº Ïàò ÏûàÏäµÎãàÎã§)');
        } finally {
            setIsGenerating(false);
        }
    };

    const handleSmartSync = async () => {
        if (!subtitles.length) return alert('ÏûêÎßâÏù¥ ÏóÜÏäµÎãàÎã§.');
        const fileToSync = audioFile || videoFile;
        if (!fileToSync) return alert('ÏòÅÏÉÅ ÎòêÎäî ÏùåÏÑ± ÌååÏùºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.');

        // Warning for large files (optional, but good for UX)
        if (fileToSync.size > 50 * 1024 * 1024) {
            if (!confirm('ÌååÏùº ÌÅ¨Í∏∞Í∞Ä Ïª§ÏÑú ÏãúÍ∞ÑÏù¥ Ïò§Îûò Í±∏Î¶¥ Ïàò ÏûàÏäµÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;
        }

        setIsSyncing(true);
        try {
            const reader = new FileReader();
            reader.readAsDataURL(fileToSync);

            const base64Data = await new Promise<string>((resolve, reject) => {
                reader.onload = () => {
                    const result = reader.result as string;
                    // remove prefix "data:video/mp4;base64,"
                    const base64 = result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
            });

            const transcript = subtitles.map(s => s.text);

            const response = await fetch('/api/gemini/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    audioData: base64Data,
                    transcript
                })
            });

            const result = await response.json();

            if (!result.ok) throw new Error(result.error || 'Sync failed');

            const aligned = result.alignedData; // [{ index, text, startTime, endTime }]

            const newSubtitles = [...subtitles];

            // Update timestamps based on index
            if (Array.isArray(aligned)) {
                aligned.forEach((item: any) => {
                    // item.index should be 1-based
                    const idx = (item.index || 0) - 1;

                    // Fallback if index missing: use array index if lengths match
                    const targetIdx = (item.index !== undefined) ? idx : subtitles.findIndex(s => s.text === item.text);

                    if (targetIdx >= 0 && targetIdx < newSubtitles.length) {
                        // Only update if duration is valid > 0
                        if (item.endTime > item.startTime) {
                            let newStart = item.startTime;
                            // Lead-in compensation: If animation is active, start slightly earlier
                            if (animationStyle !== 'none') {
                                newStart = Math.max(0, newStart - 0.15); // 0.15s lead-in
                            }

                            newSubtitles[targetIdx].startTime = newStart;
                            newSubtitles[targetIdx].endTime = item.endTime;
                        }
                    }
                });
                setSubtitles(newSubtitles);
                alert('Ïã±ÌÅ¨ Î≥¥Ï†ïÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!');
            } else {
                throw new Error('Invalid response format');
            }

        } catch (error: any) {
            console.error('Smart Sync Failed:', error);
            alert('Ïã±ÌÅ¨ Î≥¥Ï†ï Ïã§Ìå®: ' + error.message);
        } finally {
            setIsSyncing(false);
        }
    };

    const handleTranslate = async () => {
        if (subtitles.length === 0) return alert('Î≤àÏó≠Ìï† ÏûêÎßâÏù¥ ÏóÜÏäµÎãàÎã§.');

        // Get full language name for the API
        const langLabel = TRANSLATION_LANGUAGES.find(l => l.id === selectedTranslationLang)?.label || 'English';

        setIsTranslating(true);
        try {
            const { data: { session } } = await supabase.auth.getSession();
            const token = session?.access_token;

            const response = await fetch('/api/subtitle/translate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': token ? `Bearer ${token}` : ''
                },
                body: JSON.stringify({
                    subtitles,
                    targetLang: langLabel // Send full language name for better translation
                })
            });

            const result = await response.json();
            if (result.ok && Array.isArray(result.data)) {
                // Store translation in translatedText, keep original text
                const translatedSubtitles = subtitles.map((sub, idx) => ({
                    ...sub,
                    translatedText: result.data[idx] || '' // Store translation separately
                }));
                setSubtitles(translatedSubtitles);
            } else {
                throw new Error(result.message || 'Translation failed');
            }
        } catch (error) {
            console.error('Translation error:', error);
            alert('Î≤àÏó≠ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
        } finally {
            setIsTranslating(false);
        }
    };

    const formatTime = (seconds: number) => {
        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 100);
        return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    };

    // Parse time string "MM:SS.ms" back to seconds
    const parseTime = (timeStr: string): number | null => {
        const match = timeStr.match(/^(\d+):(\d+)\.?(\d*)$/);
        if (!match) return null;
        const min = parseInt(match[1], 10);
        const sec = parseInt(match[2], 10);
        const ms = match[3] ? parseInt(match[3].padEnd(2, '0').slice(0, 2), 10) : 0;
        return min * 60 + sec + ms / 100;
    };

    // Apply offset to all subtitles (shift all times)
    const applyOffset = (offsetSeconds: number) => {
        setSubtitles(subtitles.map(sub => ({
            ...sub,
            startTime: Math.max(0, sub.startTime + offsetSeconds),
            endTime: Math.max(0.1, sub.endTime + offsetSeconds)
        })));
    };

    const handleExport = () => {
        if (subtitles.length === 0) return alert('ÎÇ¥Î≥¥ÎÇº ÏûêÎßâÏù¥ ÏóÜÏäµÎãàÎã§.');

        const toSrtTime = (seconds: number) => {
            const date = new Date(0);
            date.setMilliseconds(seconds * 1000);
            return date.toISOString().substr(11, 12).replace('.', ',');
        };

        const srtContent = subtitles.map((sub, index) => {
            return `${index + 1}\n${toSrtTime(sub.startTime)} --> ${toSrtTime(sub.endTime)}\n${sub.text}\n`;
        }).join('\n');

        const blob = new Blob([srtContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `subtitles_${Date.now()}.srt`;
        a.click();
        URL.revokeObjectURL(url);
    };

    // Get current active subtitle (exclusive end time to avoid overlap)
    const currentSubtitle = subtitles.find(sub => currentTime >= sub.startTime && currentTime < sub.endTime);

    // Get per-subtitle style classes (animation, fontSize, fontFamily)
    const getSubtitleAnimationClass = (sub: Subtitle) => ANIMATION_STYLES.find(s => s.id === sub.animation)?.class || '';
    const getSubtitleFontSizeClass = (sub: Subtitle) => FONT_SIZES.find(s => s.id === sub.fontSize)?.class || 'text-[16px]';
    const getSubtitleFontFamilyStyle = (sub: Subtitle) => FONT_FAMILIES.find(s => s.id === sub.fontFamily)?.style || { fontFamily: '"Malgun Gothic", sans-serif' };


    return (
        <div className="min-h-screen bg-gray-50 dark:bg-black font-sans text-gray-900 dark:text-gray-100 flex flex-col">
            <Header />

            {/* Custom Animations Styles */}
            <style jsx global>{`
                /* 1. Fade In */
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                .animate-fade {
                    animation: fadeIn 0.4s ease-out forwards;
                }

                /* 2. Pop Up (Scale) - Fast & Snappy (CapCut style) */
                @keyframes popIn {
                    0% { transform: scale(0.8); opacity: 0; }
                    60% { transform: scale(1.05); }
                    100% { transform: scale(1); opacity: 1; }
                }
                .animate-pop {
                    animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
                }

                /* 3. Slide Up */
                @keyframes slideUp {
                    from { transform: translateY(20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                .animate-slide-up {
                    animation: slideUp 0.4s ease-out forwards;
                }

                /* 4. Slide Down */
                @keyframes slideDown {
                    from { transform: translateY(-20px); opacity: 0; }
                    to { transform: translateY(0); opacity: 1; }
                }
                .animate-slide-down {
                    animation: slideDown 0.4s ease-out forwards;
                }

                /* 5. Typewriter */
                @keyframes typewriter {
                    from { width: 0; }
                    to { width: 100%; }
                }
                .animate-typewriter {
                    animation: typewriter 1.5s steps(40, end) forwards;
                }

                /* 6. Neon Pulse */
                @keyframes neon {
                    0%, 100% { 
                        text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #e60073, 0 0 30px #e60073, 0 0 40px #e60073;
                    }
                    50% { 
                        text-shadow: 0 0 10px #fff, 0 0 20px #ff4da6, 0 0 30px #ff4da6, 0 0 40px #ff4da6, 0 0 50px #ff4da6;
                    }
                }
                .animate-neon {
                    animation: neon 1.5s infinite alternate;
                    color: #fff;
                }

                /* 7. Shake */
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
                    20%, 40%, 60%, 80% { transform: translateX(5px); }
                }
                .animate-shake {
                    animation: shake 0.6s ease-in-out;
                }

                /* 8. Zoom Out (Start big, shrink to normal) */
                @keyframes zoomOut {
                    from { transform: scale(1.5); opacity: 0; }
                    to { transform: scale(1); opacity: 1; }
                }
                .animate-zoom-out {
                    animation: zoomOut 0.5s ease-out forwards;
                }

                /* 9. Blur Reveal */
                @keyframes blurReveal {
                    from { filter: blur(15px); opacity: 0; }
                    to { filter: blur(0); opacity: 1; }
                }
                .animate-blur {
                    animation: blurReveal 0.5s ease-out forwards;
                }

                /* 10. 3D Flip */
                @keyframes flipIn {
                    0% { transform: perspective(400px) rotateX(90deg); opacity: 0; }
                    40% { transform: perspective(400px) rotateX(-15deg); }
                    70% { transform: perspective(400px) rotateX(15deg); }
                    100% { transform: perspective(400px) rotateX(0deg); opacity: 1; }
                }
                .animate-flip {
                    animation: flipIn 0.7s ease-out forwards;
                    backface-visibility: visible;
                }

                /* 11. Slide In Right (for panel) */
                @keyframes slideInRight {
                    from { transform: translateX(100%); }
                    to { transform: translateX(0); }
                }
                .animate-slide-in-right {
                    animation: slideInRight 0.3s ease-out forwards;
                }
            `}</style>

            <div className="max-w-[1920px] mx-auto w-full p-4 md:p-6 lg:p-8 min-h-[calc(100vh-64px)]">
                <div className="flex gap-4 items-start">

                    {/* LEFT COLUMN: Video Preview - Sticky */}
                    <div className="flex flex-col gap-4 flex-shrink-0 sticky top-24">
                        {/* Fixed Height Container for Video */}
                        <div className="flex flex-col gap-4">
                            {/* Video Player - Adjusted height to prevent scrolling */}
                            <div
                                ref={videoContainerRef}
                                className={`relative bg-black rounded-xl overflow-hidden shadow-xl border flex-shrink-0 transition-all ${isDragOver ? 'border-indigo-500 border-2 ring-4 ring-indigo-500/30' : 'border-gray-800'}`}
                                style={{ height: 'calc(100vh - 200px)', width: 'calc((100vh - 200px) * 9 / 16)' }}
                                onDragEnter={handleDragEnter}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                            >
                                {/* Drag Overlay */}
                                {isDragOver && (
                                    <div className="absolute inset-0 z-50 flex items-center justify-center bg-indigo-500/20 backdrop-blur-sm">
                                        <div className="bg-white dark:bg-zinc-800 px-6 py-4 rounded-xl shadow-lg text-center">
                                            <Upload className="h-8 w-8 mx-auto mb-2 text-indigo-500" />
                                            <p className="font-bold text-gray-900 dark:text-white">ÌååÏùºÏùÑ Ïó¨Í∏∞Ïóê ÎÜìÏúºÏÑ∏Ïöî</p>
                                            <p className="text-sm text-gray-500">ÏòÅÏÉÅ ÎòêÎäî ÏùåÏÑ± ÌååÏùº</p>
                                        </div>
                                    </div>
                                )}
                                {videoUrl ? (
                                    <>
                                        <video
                                            ref={videoRef}
                                            src={videoUrl}
                                            className="w-full h-full object-cover"
                                            onTimeUpdate={handleTimeUpdate}
                                            onPlay={() => setIsPlaying(true)}
                                            onPause={() => setIsPlaying(false)}
                                            onClick={togglePlay}
                                        />
                                        {/* Subtitle Overlay - Draggable */}
                                        <div
                                            className="absolute inset-0 pointer-events-none"
                                            onMouseMove={handleSubtitleDrag}
                                            onMouseUp={handleSubtitleDragEnd}
                                            onMouseLeave={handleSubtitleDragEnd}
                                            onTouchMove={handleSubtitleDrag}
                                            onTouchEnd={handleSubtitleDragEnd}
                                        >
                                            {currentSubtitle && (
                                                <div
                                                    key={currentSubtitle.id}
                                                    className={`absolute cursor-move select-none pointer-events-auto text-white flex justify-center items-center ${isDragging || isResizing ? 'ring-2 ring-indigo-400 ring-offset-2 rounded-lg' : ''}`}
                                                    style={{
                                                        left: `${subtitlePosition.x}%`,
                                                        top: `${subtitlePosition.y}%`,
                                                        transform: 'translate(-50%, -50%)',
                                                        width: `${subtitleWidth}%`,
                                                        maxWidth: '95%',
                                                    }}
                                                    onMouseDown={handleSubtitleDragStart}
                                                    onTouchStart={handleSubtitleDragStart}
                                                >
                                                    <div
                                                        key={`anim-${currentSubtitle.animation}`}
                                                        className={`w-full px-3 py-2 rounded-lg font-medium leading-relaxed ${showSubtitleBackground ? 'bg-black/70 backdrop-blur-sm shadow-lg border border-white/20' : ''} ${getSubtitleAnimationClass(currentSubtitle)}`}
                                                        style={{
                                                            ...getSubtitleFontFamilyStyle(currentSubtitle),
                                                            ...(!showSubtitleBackground ? {
                                                                WebkitTextStroke: '3px rgba(0,0,0,0.6)',
                                                                paintOrder: 'stroke fill',
                                                                textShadow: '0 2px 4px rgba(0,0,0,0.3)'
                                                            } : {})
                                                        }}
                                                    >
                                                        <div className={`${getSubtitleFontSizeClass(currentSubtitle)} text-center`}>
                                                            {currentSubtitle.text}
                                                        </div>
                                                        {currentSubtitle.translatedText && (
                                                            <div className="text-yellow-300 mt-1 text-sm font-medium text-center">
                                                                {currentSubtitle.translatedText}
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                        {/* Play Button Overlay (when paused) */}
                                        {!isPlaying && (
                                            <div className="absolute inset-0 flex items-center justify-center bg-black/20 pointer-events-none">
                                                <div className="bg-white/20 backdrop-blur-md p-4 rounded-full">
                                                    <Play className="h-8 w-8 text-white fill-current" />
                                                </div>
                                            </div>
                                        )}
                                    </>
                                ) : (
                                    <div className="flex flex-col items-center justify-center h-full text-gray-500">
                                        <VideoIcon className="h-12 w-12 mb-3 opacity-50" />
                                        <p className="font-medium text-sm">ÏòÅÏÉÅÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî</p>
                                        <p className="text-xs mt-1 opacity-60">MP4, MOV supported</p>
                                        <label className="mt-4 px-5 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full font-bold text-sm cursor-pointer transition-colors shadow-lg shadow-indigo-500/30">
                                            ÌååÏùº ÏÑ†ÌÉù
                                            <input type="file" accept="video/*" className="hidden" onChange={handleFileUpload} />
                                        </label>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* RIGHT COLUMN: Timeline & Tools */}
                    <div className="flex-1 flex flex-col bg-white dark:bg-zinc-900 rounded-2xl border border-gray-200 dark:border-zinc-800 shadow-sm">
                        {/* Sticky Toolbar Wrapper */}
                        <div className={`${isToolbarSticky ? 'sticky top-24 z-10 bg-white/95 dark:bg-zinc-900/95 backdrop-blur shadow-sm rounded-t-2xl' : ''} transition-all duration-300 z-20`}>
                            {/* Toolbar */}
                            <div className="p-4 border-b border-gray-100 dark:border-zinc-800 flex items-center justify-between bg-gray-50/50 dark:bg-zinc-900/50 flex-wrap gap-3">
                                <div className="flex items-center gap-3 mr-auto">
                                    <h2 className="font-bold text-lg flex items-center gap-2">
                                        <span className="text-indigo-600">Timeline</span>
                                    </h2>
                                    <button
                                        onClick={() => setIsToolbarSticky(!isToolbarSticky)}
                                        className={`p-1.5 rounded-lg transition-colors ${isToolbarSticky ? 'bg-indigo-100 text-indigo-600' : 'text-gray-400 hover:bg-gray-100 dark:hover:bg-zinc-800'}`}
                                        title={isToolbarSticky ? "Ìó§Îçî Í≥†Ï†ï Ìï¥Ï†ú" : "Ìó§Îçî Í≥†Ï†ï"}
                                    >
                                        {isToolbarSticky ? <Pin size={16} fill="currentColor" /> : <PinOff size={16} />}
                                    </button>
                                    {/* Input Panel Toggle Button */}
                                    <button
                                        onClick={() => setIsInputPanelOpen(true)}
                                        className="flex items-center gap-1.5 px-3 py-1.5 bg-indigo-100 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300 rounded-lg text-xs font-bold hover:bg-indigo-200 dark:hover:bg-indigo-900/50 transition-colors"
                                    >
                                        <FileText className="h-3.5 w-3.5" />
                                        üìù ÎåÄÎ≥∏ ÏûÖÎ†•
                                        {(scriptText || audioFile) && <span className="w-2 h-2 bg-green-500 rounded-full" />}
                                    </button>
                                </div>

                                {/* Time Offset Buttons */}
                                {subtitles.length > 0 && (
                                    <div className="flex items-center gap-1 bg-gray-100 dark:bg-zinc-800 rounded-lg p-1">
                                        <span className="text-xs text-gray-500 px-1">‚è±</span>
                                        <button onClick={() => applyOffset(-0.5)} className="px-2 py-1 text-xs font-bold rounded hover:bg-white dark:hover:bg-zinc-700">-0.5s</button>
                                        <button onClick={() => applyOffset(-0.1)} className="px-2 py-1 text-xs font-bold rounded hover:bg-white dark:hover:bg-zinc-700">-0.1s</button>
                                        <button onClick={() => applyOffset(0.1)} className="px-2 py-1 text-xs font-bold rounded hover:bg-white dark:hover:bg-zinc-700">+0.1s</button>
                                        <button onClick={() => applyOffset(0.5)} className="px-2 py-1 text-xs font-bold rounded hover:bg-white dark:hover:bg-zinc-700">+0.5s</button>
                                    </div>
                                )}

                                {/* Animation Selector */}
                                <div className="flex items-center gap-2">
                                    <span className="text-xs font-bold text-gray-500 uppercase tracking-wider">Effect:</span>
                                    <select
                                        value={animationStyle}
                                        onChange={(e) => setAnimationStyle(e.target.value)}
                                        className="h-9 rounded-lg border-gray-300 dark:border-zinc-700 bg-white dark:bg-zinc-800 text-sm font-medium focus:ring-indigo-500 focus:border-indigo-500"
                                    >
                                        {ANIMATION_STYLES.map(style => (
                                            <option key={style.id} value={style.id}>{style.label}</option>
                                        ))}
                                    </select>
                                </div>

                                {/* Background Toggle */}
                                <button
                                    onClick={() => setShowSubtitleBackground(!showSubtitleBackground)}
                                    className={`h-9 px-3 rounded-lg text-xs font-bold transition-colors ${showSubtitleBackground
                                        ? 'bg-gray-800 text-white'
                                        : 'bg-gray-200 dark:bg-zinc-700 text-gray-600 dark:text-gray-300'}`}
                                >
                                    {showSubtitleBackground ? 'Î∞∞Í≤Ω ON' : 'Î∞∞Í≤Ω OFF'}
                                </button>

                                {/* Subtitle Position Controls */}
                                <div className="flex items-center gap-1 bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-lg overflow-hidden">
                                    <button
                                        onClick={() => setSubtitlePosition(prev => ({ x: 50, y: prev.y }))}
                                        className="h-9 px-2 text-xs font-bold text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-zinc-700 transition-colors"
                                        title="Ï§ëÏïô Ï†ïÎ†¨ (Í∏∞Î≥∏ ÏúÑÏπò)"
                                    >
                                        ‚ÜîÔ∏è Ï§ëÏïô
                                    </button>
                                    <div className="flex items-center gap-1 px-2 border-l border-gray-200 dark:border-zinc-700">
                                        <span className="text-xs text-gray-500">Y:</span>
                                        <input
                                            type="number"
                                            min="5"
                                            max="95"
                                            value={Math.round(subtitlePosition.y)}
                                            onChange={(e) => setSubtitlePosition(prev => ({ ...prev, y: Number(e.target.value) }))}
                                            className="w-12 h-7 px-1 text-xs text-center rounded border border-gray-200 dark:border-zinc-600 bg-gray-50 dark:bg-zinc-900"
                                        />
                                        <span className="text-xs text-gray-400">%</span>
                                    </div>
                                    <div className="flex items-center gap-1 px-2 border-l border-gray-200 dark:border-zinc-700">
                                        <span className="text-xs text-gray-500">W:</span>
                                        <input
                                            type="range"
                                            min="30"
                                            max="95"
                                            step="5"
                                            value={subtitleWidth}
                                            onChange={(e) => setSubtitleWidth(Number(e.target.value))}
                                            className="w-16 h-7 accent-indigo-600 cursor-pointer"
                                            title="ÏûêÎßâ ÎÑàÎπÑ Ï°∞Ï†à"
                                        />
                                        <span className="text-xs text-gray-400 w-7 text-right">{subtitleWidth}%</span>
                                    </div>
                                </div>

                                <div className="flex gap-2">
                                    <button
                                        onClick={handleGenerateSubtitles}
                                        disabled={isGenerating || !videoFile}
                                        className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-lg font-bold text-sm hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed shadow-md shadow-indigo-500/20"
                                    >
                                        {isGenerating ? <span className="animate-spin">üåÄ</span> : <Wand2 className="h-4 w-4" />}
                                        AI ÏûêÎßâ ÏÉùÏÑ±
                                    </button>

                                    <button
                                        onClick={handleSmartSync}
                                        disabled={isSyncing || !subtitles.length}
                                        className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-emerald-500 to-teal-500 text-white rounded-lg font-bold text-sm hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed shadow-md shadow-emerald-500/20"
                                        title="AIÍ∞Ä ÏùåÏÑ±Ïóê ÎßûÏ∂∞ ÏûêÎßâ ÏãúÍ∞ÑÏùÑ ÏûêÎèôÏúºÎ°ú Ï°∞Ï†àÌï©ÎãàÎã§"
                                    >
                                        <RefreshCw className={`h-4 w-4 ${isSyncing ? 'animate-spin' : ''}`} />
                                        AI Ïã±ÌÅ¨ Î≥¥Ï†ï
                                    </button>

                                    {/* Translation Section with Language Selector */}
                                    <div className="flex items-center gap-1 bg-white dark:bg-zinc-800 border border-gray-200 dark:border-zinc-700 rounded-lg overflow-hidden">
                                        <select
                                            value={selectedTranslationLang}
                                            onChange={(e) => setSelectedTranslationLang(e.target.value)}
                                            className="h-9 px-2 text-xs font-medium border-none bg-transparent focus:ring-0"
                                        >
                                            {TRANSLATION_LANGUAGES.map(lang => (
                                                <option key={lang.id} value={lang.id}>{lang.label}</option>
                                            ))}
                                        </select>
                                        <button
                                            onClick={handleTranslate}
                                            disabled={isTranslating || subtitles.length === 0}
                                            className="flex items-center gap-2 px-3 py-2 text-gray-700 dark:text-gray-300 font-bold text-sm hover:bg-gray-50 dark:hover:bg-zinc-700 transition-colors disabled:opacity-50 border-l border-gray-200 dark:border-zinc-700"
                                        >
                                            {isTranslating ? <span className="animate-spin">üåÄ</span> : <Globe className="h-4 w-4" />}
                                            Î≤àÏó≠
                                        </button>
                                    </div>
                                    <button
                                        onClick={handleExport}
                                        className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg font-bold text-sm hover:bg-green-700 transition-colors shadow-md shadow-green-500/20"
                                    >
                                        <Download className="h-4 w-4" />
                                        ÎÇ¥Î≥¥ÎÇ¥Í∏∞ (.srt)
                                    </button>
                                </div>
                            </div>

                            {/* List Header */}
                            <div className="grid grid-cols-12 gap-2 px-4 py-2 border-b border-gray-100 dark:border-zinc-800 text-xs font-bold text-gray-500 uppercase tracking-wider bg-gray-50 dark:bg-zinc-950/30">
                                <div className="col-span-1">ÏãúÏûë</div>
                                <div className="col-span-1">Ï¢ÖÎ£å</div>
                                <div className="col-span-5">ÎÇ¥Ïö©</div>
                                <div className="col-span-2">Ìö®Í≥º</div>
                                <div className="col-span-1">ÌÅ¨Í∏∞</div>
                                <div className="col-span-1">Ìè∞Ìä∏</div>
                                <div className="col-span-1 text-center">ÏÇ≠Ï†ú</div>
                            </div>
                        </div>

                        {/* Timeline List */}
                        <div className="p-2 space-y-1">
                            {subtitles.length === 0 ? (
                                <div className="py-20 flex flex-col items-center justify-center text-gray-400 opacity-60">
                                    <Wand2 className="h-12 w-12 mb-4" />
                                    <p>ÎåÄÎ≥∏Í≥º ÏòÅÏÉÅÏùÑ ÎÑ£Í≥† 'AI ÏûêÎßâ ÏÉùÏÑ±'ÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî</p>
                                </div>
                            ) : (
                                subtitles.map((sub) => (
                                    <div
                                        key={sub.id}
                                        className={`grid grid-cols-12 gap-2 p-2 rounded-lg items-center transition-all border text-xs ${currentTime >= sub.startTime && currentTime <= sub.endTime
                                            ? 'bg-indigo-50 border-indigo-200 dark:bg-indigo-900/20 dark:border-indigo-800 shadow-sm'
                                            : 'bg-white dark:bg-zinc-800/40 border-gray-100 dark:border-zinc-800 hover:border-gray-300 dark:hover:border-zinc-600'
                                            }`}
                                        onClick={() => {
                                            if (videoRef.current) {
                                                // Add small offset to ensure we're inside this subtitle's timeframe
                                                videoRef.current.currentTime = sub.startTime + 0.05;
                                            }
                                        }}
                                    >
                                        {/* Editable Start Time */}
                                        <input
                                            type="text"
                                            value={formatTime(sub.startTime)}
                                            onChange={(e) => {
                                                const newTime = parseTime(e.target.value);
                                                if (newTime !== null) {
                                                    setSubtitles(subtitles.map(s => s.id === sub.id ? { ...s, startTime: newTime } : s));
                                                }
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                            className="col-span-1 font-mono text-gray-600 dark:text-gray-400 bg-transparent border-none focus:ring-1 focus:ring-indigo-400 rounded text-xs w-full p-0.5 text-center"
                                        />
                                        {/* Editable End Time */}
                                        <input
                                            type="text"
                                            value={formatTime(sub.endTime)}
                                            onChange={(e) => {
                                                const newTime = parseTime(e.target.value);
                                                if (newTime !== null) {
                                                    setSubtitles(subtitles.map(s => s.id === sub.id ? { ...s, endTime: newTime } : s));
                                                }
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                            className="col-span-1 font-mono text-gray-600 dark:text-gray-400 bg-transparent border-none focus:ring-1 focus:ring-indigo-400 rounded text-xs w-full p-0.5 text-center"
                                        />

                                        {/* Content - Korean + Translation */}
                                        <div className="col-span-5">
                                            <input
                                                type="text"
                                                value={sub.text}
                                                onChange={(e) => {
                                                    setSubtitles(subtitles.map(s => s.id === sub.id ? { ...s, text: e.target.value } : s));
                                                }}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') {
                                                        e.preventDefault();
                                                        const target = e.currentTarget;
                                                        const cursorPosition = target.selectionStart || 0;
                                                        const text = sub.text;
                                                        const part1Text = text.slice(0, cursorPosition).trim();
                                                        const part2Text = text.slice(cursorPosition).trim();
                                                        if (!part1Text && !part2Text) return;
                                                        const duration = sub.endTime - sub.startTime;
                                                        const totalLength = part1Text.length + part2Text.length;
                                                        let splitRatio = 0.5;
                                                        if (totalLength > 0) {
                                                            splitRatio = part1Text.length / totalLength;
                                                        }
                                                        const splitTime = sub.startTime + (duration * splitRatio);
                                                        const updatedCurrent = { ...sub, text: part1Text, endTime: splitTime };
                                                        const newNext = { id: `split-${Date.now()}`, startTime: splitTime, endTime: sub.endTime, text: part2Text, animation: sub.animation, fontSize: sub.fontSize, fontFamily: sub.fontFamily, translatedText: sub.translatedText ? '' : undefined };
                                                        const currentIndex = subtitles.findIndex(s => s.id === sub.id);
                                                        const newSubtitles = [...subtitles];
                                                        newSubtitles[currentIndex] = updatedCurrent;
                                                        newSubtitles.splice(currentIndex + 1, 0, newNext);
                                                        setSubtitles(newSubtitles);
                                                    }
                                                    // Delete at end of text: merge with next subtitle
                                                    if (e.key === 'Delete') {
                                                        const target = e.currentTarget;
                                                        const cursorPosition = target.selectionStart || 0;
                                                        const text = sub.text;

                                                        // Only merge if cursor is at the end of text
                                                        if (cursorPosition === text.length) {
                                                            const currentIndex = subtitles.findIndex(s => s.id === sub.id);
                                                            const nextSubtitle = subtitles[currentIndex + 1];

                                                            if (nextSubtitle) {
                                                                e.preventDefault();

                                                                // Merge: current text + space + next text
                                                                const mergedText = `${sub.text} ${nextSubtitle.text}`.trim();

                                                                // Use current startTime and next endTime
                                                                const mergedSubtitle = {
                                                                    ...sub,
                                                                    text: mergedText,
                                                                    endTime: nextSubtitle.endTime,
                                                                    // Keep translation if exists
                                                                    translatedText: sub.translatedText && nextSubtitle.translatedText
                                                                        ? `${sub.translatedText} ${nextSubtitle.translatedText}`.trim()
                                                                        : sub.translatedText || nextSubtitle.translatedText
                                                                };

                                                                // Remove next subtitle and update current
                                                                const newSubtitles = subtitles.filter((_, i) => i !== currentIndex + 1);
                                                                newSubtitles[currentIndex] = mergedSubtitle;
                                                                setSubtitles(newSubtitles);
                                                            }
                                                        }
                                                    }
                                                    // Backspace at start of text: merge with previous subtitle
                                                    if (e.key === 'Backspace') {
                                                        const target = e.currentTarget;
                                                        const cursorPosition = target.selectionStart || 0;

                                                        // Only merge if cursor is at the beginning of text
                                                        if (cursorPosition === 0) {
                                                            const currentIndex = subtitles.findIndex(s => s.id === sub.id);
                                                            const prevSubtitle = subtitles[currentIndex - 1];

                                                            if (prevSubtitle) {
                                                                e.preventDefault();

                                                                // Merge: prev text + space + current text
                                                                const mergedText = `${prevSubtitle.text} ${sub.text}`.trim();

                                                                // Use prev startTime and current endTime
                                                                const mergedSubtitle = {
                                                                    ...prevSubtitle,
                                                                    text: mergedText,
                                                                    endTime: sub.endTime,
                                                                    translatedText: prevSubtitle.translatedText && sub.translatedText
                                                                        ? `${prevSubtitle.translatedText} ${sub.translatedText}`.trim()
                                                                        : prevSubtitle.translatedText || sub.translatedText
                                                                };

                                                                // Remove current subtitle and update previous
                                                                const newSubtitles = subtitles.filter((_, i) => i !== currentIndex);
                                                                newSubtitles[currentIndex - 1] = mergedSubtitle;
                                                                setSubtitles(newSubtitles);
                                                            }
                                                        }
                                                    }
                                                }}
                                                className="w-full bg-transparent border-none focus:ring-0 text-sm font-medium text-gray-800 dark:text-gray-200 p-0"
                                            />
                                            {/* Translation Display */}
                                            {sub.translatedText && (
                                                <div className="text-amber-600 dark:text-amber-400 text-xs mt-0.5 truncate" title={sub.translatedText}>
                                                    {sub.translatedText}
                                                </div>
                                            )}
                                        </div>

                                        {/* Animation Selector */}
                                        <div className="col-span-2">
                                            <select
                                                value={sub.animation || 'none'}
                                                onClick={(e) => e.stopPropagation()}
                                                onChange={(e) => {
                                                    e.stopPropagation();
                                                    setSubtitles(subtitles.map(s => s.id === sub.id ? { ...s, animation: e.target.value } : s));
                                                }}
                                                className="w-full h-7 text-xs rounded border-gray-200 dark:border-zinc-700 bg-gray-50 dark:bg-zinc-900"
                                            >
                                                {ANIMATION_STYLES.map(style => (
                                                    <option key={style.id} value={style.id}>{style.label}</option>
                                                ))}
                                            </select>
                                        </div>

                                        {/* Font Size Selector */}
                                        <div className="col-span-1">
                                            <select
                                                value={sub.fontSize || 'base'}
                                                onClick={(e) => e.stopPropagation()}
                                                onChange={(e) => {
                                                    e.stopPropagation();
                                                    setSubtitles(subtitles.map(s => s.id === sub.id ? { ...s, fontSize: e.target.value } : s));
                                                }}
                                                className="w-full h-7 text-xs rounded border-gray-200 dark:border-zinc-700 bg-gray-50 dark:bg-zinc-900"
                                            >
                                                {FONT_SIZES.map(size => (
                                                    <option key={size.id} value={size.id}>{size.label}</option>
                                                ))}
                                            </select>
                                        </div>

                                        {/* Font Family Selector */}
                                        <div className="col-span-1">
                                            <select
                                                value={sub.fontFamily || 'sans'}
                                                onClick={(e) => e.stopPropagation()}
                                                onChange={(e) => {
                                                    e.stopPropagation();
                                                    setSubtitles(subtitles.map(s => s.id === sub.id ? { ...s, fontFamily: e.target.value } : s));
                                                }}
                                                className="w-full h-7 text-xs rounded border-gray-200 dark:border-zinc-700 bg-gray-50 dark:bg-zinc-900"
                                            >
                                                {FONT_FAMILIES.map(font => (
                                                    <option key={font.id} value={font.id}>{font.label}</option>
                                                ))}
                                            </select>
                                        </div>

                                        {/* Delete Button */}
                                        <div className="col-span-1 flex justify-center">
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setSubtitles(subtitles.filter(s => s.id !== sub.id));
                                                }}
                                                className="p-1 text-gray-400 hover:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/30 rounded transition-colors"
                                            >
                                                <Trash2 className="h-3.5 w-3.5" />
                                            </button>
                                        </div>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            </div>

            {/* Input Slide Panel */}
            {
                isInputPanelOpen && (
                    <div className="fixed inset-0 z-50 flex justify-end">
                        {/* Backdrop */}
                        <div
                            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                            onClick={() => setIsInputPanelOpen(false)}
                        />

                        {/* Panel */}
                        <div className="relative w-full max-w-md bg-white dark:bg-zinc-900 h-full shadow-2xl flex flex-col animate-slide-in-right">
                            {/* Header */}
                            <div className="p-4 border-b border-gray-200 dark:border-zinc-800 flex items-center justify-between">
                                <h3 className="font-bold text-lg">üìù ÎåÄÎ≥∏ & ÏùåÏÑ± ÏûÖÎ†•</h3>
                                <button
                                    onClick={() => setIsInputPanelOpen(false)}
                                    className="p-2 hover:bg-gray-100 dark:hover:bg-zinc-800 rounded-lg"
                                >
                                    ‚úï
                                </button>
                            </div>

                            {/* Content */}
                            <div className="flex-1 p-4 flex flex-col gap-4 overflow-y-auto">
                                {/* Audio File Drop Zone */}
                                <div className="space-y-2">
                                    <label className="text-sm font-bold text-gray-700 dark:text-gray-300 flex items-center gap-2">
                                        üéµ ÏùåÏÑ± ÌååÏùº (ÏÑ†ÌÉù)
                                    </label>
                                    <div
                                        className={`border-2 border-dashed rounded-xl p-6 text-center transition-colors ${audioFile
                                            ? 'border-green-400 bg-green-50 dark:bg-green-900/20'
                                            : 'border-gray-300 dark:border-zinc-700 hover:border-indigo-400'
                                            }`}
                                        onDragOver={(e) => e.preventDefault()}
                                        onDrop={(e) => {
                                            e.preventDefault();
                                            const file = e.dataTransfer.files[0];
                                            if (file?.type.startsWith('audio/')) {
                                                setAudioFile(file);
                                            }
                                        }}
                                    >
                                        {audioFile ? (
                                            <div className="flex items-center justify-center gap-2">
                                                <span className="text-green-600 dark:text-green-400 font-medium">
                                                    ‚úì {audioFile.name}
                                                </span>
                                                <button
                                                    onClick={() => setAudioFile(null)}
                                                    className="text-red-500 hover:text-red-700"
                                                >‚úï</button>
                                            </div>
                                        ) : (
                                            <>
                                                <Upload className="h-8 w-8 mx-auto mb-2 text-gray-400" />
                                                <p className="text-sm text-gray-500">ÎìúÎûòÍ∑∏ÌïòÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÏó¨ ÏóÖÎ°úÎìú</p>
                                                <label className="mt-2 inline-block px-4 py-2 bg-gray-100 dark:bg-zinc-800 rounded-lg text-sm font-medium cursor-pointer hover:bg-gray-200 dark:hover:bg-zinc-700">
                                                    ÌååÏùº ÏÑ†ÌÉù
                                                    <input
                                                        type="file"
                                                        accept="audio/*"
                                                        className="hidden"
                                                        onChange={(e) => setAudioFile(e.target.files?.[0] || null)}
                                                    />
                                                </label>
                                            </>
                                        )}
                                    </div>
                                </div>

                                {/* Script Input */}
                                <div className="flex-1 flex flex-col space-y-2">
                                    <label className="text-sm font-bold text-gray-700 dark:text-gray-300 flex items-center gap-2">
                                        üìù ÏõêÎ≥∏ ÎåÄÎ≥∏ (ÌïÑÏàò)
                                    </label>
                                    <textarea
                                        value={scriptText}
                                        onChange={(e) => setScriptText(e.target.value)}
                                        placeholder="Ïó¨Í∏∞Ïóê ÎåÄÎ≥∏ÏùÑ Î∂ôÏó¨ÎÑ£ÏúºÏÑ∏Ïöî.&#10;&#10;Whisper + GeminiÍ∞Ä ÏòÅÏÉÅ/ÏùåÏÑ±Í≥º Ïã±ÌÅ¨Î•º ÎßûÏ∂∞ ÏûêÎßâÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§."
                                        className="flex-1 min-h-[200px] w-full p-4 bg-gray-50 dark:bg-zinc-800 rounded-xl border border-gray-200 dark:border-zinc-700 resize-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-sm leading-relaxed"
                                    />
                                </div>
                            </div>

                            {/* Footer */}
                            <div className="p-4 border-t border-gray-200 dark:border-zinc-800 flex gap-2">
                                <button
                                    onClick={() => setIsInputPanelOpen(false)}
                                    className="flex-1 py-3 bg-gray-100 dark:bg-zinc-800 rounded-xl font-bold hover:bg-gray-200 dark:hover:bg-zinc-700 transition-colors"
                                >
                                    Îã´Í∏∞
                                </button>
                                <button
                                    onClick={() => {
                                        setIsInputPanelOpen(false);
                                        handleGenerateSubtitles();
                                    }}
                                    disabled={!scriptText || !videoFile || isGenerating}
                                    className="flex-1 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-xl font-bold hover:opacity-90 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                                >
                                    {isGenerating ? (
                                        <><span className="animate-spin">üåÄ</span> ÏÉùÏÑ± Ï§ë...</>
                                    ) : (
                                        <><Wand2 className="h-4 w-4" /> AI ÏûêÎßâ ÏÉùÏÑ±</>
                                    )}
                                </button>
                            </div>
                        </div>
                    </div>
                )
            }
        </div >
    );
}
